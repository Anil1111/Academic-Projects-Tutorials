React.js is a JavaScript library. It was developed by engineers at Facebook.

What is JSX?
JSX is a syntax extension for JavaScript. It was written to be used with React. JSX code looks a lot like HTML.
In this case, it means that JSX is not valid JavaScript. Web browsers can’t read it!
If a JavaScript file contains JSX code, then that file will have to be compiled. That means that before the file reaches a web browser, a JSX compiler will translate any JSX into regular JavaScript.

Here’s an example of a JSX element:
<h1>Hello world</h1>
JSX elements are treated as JavaScript expressions. They can go anywhere that JavaScript expressions can go.
That means that a JSX element can be saved in a variable, passed to a function, stored in an object or array

several JSX elements being stored in an object:
const myTeam = {
  center: <li>Benzo Walli</li>,
  powerForward: <li>Rasha Loa</li>,
  smallForward: <li>Tayshaun Dasmoto</li>,
  shootingGuard: <li>Colmar Cumberbatch</li>,
  pointGuard: <li>Femi Billon</li>
};

A single JSX element can have many attributes, just like in HTML:
const panda = <img src="images/panda.jpg" alt="panda" width="500px" height="500px" />;

NESTED JSX
const theExample = (
   <a href="https://www.example.com">
     <h1>
       Click me!
     </h1>
   </a>
 );

 a JSX expression must have exactly one outermost element.
 The first opening tag and the final closing tag of a JSX expression must belong to the same JSX element!

 Rendering JSX
 To render a JSX expression means to make it appear onscreen.
 The following code will render a JSX expression:
ReactDOM.render(<h1>Hello world</h1>, document.getElementById('app'));

ReactDOM is the name of a JavaScript library. This library contains several React-specific methods, all of which deal with the DOM in some way or another.
ReactDOM.render() is the most common way to render JSX. It takes a JSX expression, creates a corresponding tree of DOM nodes, and adds that tree to the DOM.

ReactDOM.render()‘s first argument should evaluate to a JSX expression, it doesn’t have to literally be a JSX expression.
const toDoList = (
  <ol>
    <li>Learn React</li>
    <li>Become a Developer</li>
  </ol>
);

ReactDOM.render(
  toDoList, 
  document.getElementById('app')
);

is that it only updates DOM elements that have changed.
That means that if you render the exact same thing twice in a row, the second render will do nothing:

Problem of DOM Manipulation:
This slowness is made worse by the fact that most JavaScript frameworks update the DOM much more than they have to.
The Virtual DOM
In React, for every DOM object, there is a corresponding “virtual DOM object.” A virtual DOM object is a representation of a DOM object, like a lightweight copy.'A virtual DOM object has the same properties as a real DOM object, but it lacks the real thing’s power to directly change what’s on the screen.
Manipulating the DOM is slow. Manipulating the virtual DOM is much faster, because nothing gets drawn onscreen. 

In summary, here’s what happens when you try to update the DOM in React:
The entire virtual DOM gets updated.
The virtual DOM gets compared to what it looked like before you updated it. React figures out which objects have changed.
-By comparing the new virtual DOM with a pre-update version, React figures out exactly which virtual DOM objects have changed. This process is called “diffing.”
The changed objects, and the changed objects only, get updated on the real DOM.
Changes on the real DOM cause the screen to change.


Advanced JSX:

1. class vs className
Grammar in JSX is mostly the same as in HTML, but there are subtle differences to watch out for. Probably the most frequent of these involves the word class.
In JSX, you can’t use the word class! You have to use className instead:
<h1 className="big">Hey</h1>
This is because JSX gets translated into JavaScript, and class is a reserved word in JavaScript.
When JSX is rendered, JSX className attributes are automatically rendered as class attributes.
React elements and react components: https://reactkungfu.com/2015/10/the-difference-between-virtual-dom-and-dom/

2. Self-Closing Tags
In JSX, you have to include the slash. If you write a self-closing tag in JSX and forget the slash, you will raise an error:
<br/> is valid and not <br>

3. Curly braces in JSX
Any code in between the tags of a JSX element will be read as JSX, not as regular JavaScript! JSX doesn’t add numbers - it reads them as text, just like HTML. The bwlow wil render in HTML as 2+3
ReactDOM.render(
  <h1>2 + 3</h1>,
  document.getElementById('app')
);

4. JS in JSX
treat me like ordinary JavaScript and not like JSX.”
You can do this by wrapping your code in curly braces.
<h1>{2 + 3}</h1>

5.Variables in JSX
That means that you can access variables while inside of a JSX expression, even if those variables were declared on the outside.
const name = 'Gerdo';

// Access your variable // from inside of a JSX expression:
const greeting = <p>Hello, {name}!</p>;

6. Variable Attributes in JSX
When writing JSX, it’s common to use variables to set attributes.

// Use a variable to set the `height` and `width` attributes:
const sideLength = "200px";

const panda = (
  <img 
    src="images/panda.jpg" 
    alt="panda" 
    height={sideLength} 
    width={sideLength} />
);

7. Event Listeners in JSX
You create an event listener by giving a JSX element a special attribute. Here’s an example:
<img onClick={myFunc} />

function myFunc() {
  alert('Make myFunc the pFunc... omg that was horrible i am so sorry');
}
Note that in HTML, event listener names are written in all lowercase, such as onclick or onmouseover. In JSX, event listener names are written in camelCase, such as onClick or onMouseOver.

8. JSX Conditionals: If Statements That Don't Work
Here’s a rule that you need to know: you can not inject an if statement into a JSX expression.
(
  <h1>
    {
      if (purchase.complete) {
        'Thank you for placing an order!'
      }
    }
  </h1>
)

9. Conditionals that work:
How can you write a conditional, if you can’t inject an if statement into JSX?
Well, one option is to write an if statement, and not inject it into JSX.
if (coinToss() === 'heads') {
  img = <img src={pics.kitty}/>
} else {
  img = <img src={pics.doggy}/>
}
ReactDOM.render(img, document.getElementById('app'));

10. JSX Conditionals: The Ternary Operator
const headline = (
  <h1>
    { age >= drinkingAge ? 'Buy Drink' : 'Do Teen Stuff' }
  </h1>
);

const img = <img src={pics[coinToss() === 'heads' ? kitty : doggy]} />;


11.JSX Conditionals: &&
&& works best in conditionals that will sometimes do an action, but other times do nothing at all.
const tasty = (
  <ul>
    <li>Applesauce</li>
    { !baby && <li>Pizza</li> }
    { age > 15 && <li>Brussels Sprouts</li> }
    { age > 20 && <li>Oysters</li> }
    { age > 25 && <li>Grappa</li> }
  </ul>
);

12. .map in JSX
const strings = ['Home', 'Shop', 'About Me'];
const listItems = strings.map(string => <li>{string}</li>);
<ul>{listItems}</ul>

13. Keys:
<ul>
  <li key="li-01">Example1</li>
  <li key="li-02">Example2</li>
  <li key="li-03">Example3</li>
</ul>

A key is a JSX attribute. The attribute’s name is key. The attribute’s value should be something unique, similar to an id attribute.
keys don’t do anything that you can see! React uses them internally to keep track of lists. 
Not all lists need to have keys. A list needs keys if either of the following are true:
- The list-items have memory from one render to the next. For instance, when a to-do list renders, each item must “remember” whether it was checked off.
- A list’s order might be shuffled. For instance, a list of search results might be shuffled from one render to the next.
const people = ['Rowe', 'Prevost', 'Gare'];

const peopleLis = people.map((person, i) =>
  <li key={'person_'+i}>{person}</li>
);
ReactDOM.render(<ul>{peopleLis}</ul>, document.getElementById('app'));

14. React.createElement
The following JSX expression:
const h1 = <h1>Hello world</h1>;

can be rewritten without JSX, like this:
const h1 = React.createElement(
  "h1",
  null,
  "Hello, world"
);
When a JSX element is compiled, the compiler transforms the JSX element into the method that you see above: React.createElement(). Every JSX element is secretly a call to React.createElement().


REACT COMPONENT:
React component is a small, reusable chunk of code that is responsible for one job, which often involves rendering HTML.
This code will create and render a new React component:

import React from 'react';
- This imported object contains methods that you need in order to use React. The object is called the React library.
import ReactDOM from 'react-dom';
-The methods imported from 'react-dom' are meant for interacting with the DOM. 

A render method must contain a return statement. Usually, this return statement returns a JSX expression:
class MyComponentClass extends React.Component {
  render() {
    return <h1>Hello world</h1>;
  }
};

ReactDOM.render(
  <MyComponentClass />,
  document.getElementById('app')
);

every component must come from a component class.
A component class is like a factory that creates components. If you have a component class, then you can use that class to produce as many components as you want.
To make a component class, you use a base class from the React library: React.Component.
React.Component is a JavaScript class. To create your own component class, you must subclass React.Component. You can do this by using the syntax class YourComponentNameGoesHere extends React.Component {}.

To make a React component, you write a JSX element. Instead of naming your JSX element something like h1 or div like you’ve done before, give it the same name as a component class. Voilà, there’s your component instance!

**JSX elements can be either HTML-like, or component instances. JSX uses capitalization to distinguish between the two! That is the React-specific reason why component class names must begin with capital letters. In a JSX element, that capitalized first letter says, “I will be a component instance and not an HTML tag.”

ReactDOM.render() will tell <MyComponentClass /> to call its render method.
<MyComponentClass /> will call its render method, which will return the JSX element <h1>Hello world</h1>.

Use a Variable Attribute in a Component
const redPanda = {
  src: 'https://upload.wikimedia.org/wikipedia/commons/b/b2/Endangered_Red_Panda.jpg',
  alt: 'Red Panda',  width:  '200px'
};

class RedPanda extends React.Component {
  render() {
    return (
      <div>
        <h1>Cute Red Panda</h1>
        <img         src={redPanda.src}          alt={redPanda.alt}          width={redPanda.width} />
      </div>
    );
  }
}


Put Logic in a Render Function

class Random extends React.Component {
  render() {
    const n = Math.floor(Math.random() * 10 + 1);
    return <h1>The number is {n}!</h1>;
  }
}

Use a Conditional in a Render Function
Notice that the if statement is located inside of the render function, but before the return statement

Use this in a Component
You are especially likely to see this inside of the body of a component class declaration. Here’s an example:

class IceCreamGuy extends React.Component {
  get food() {
    return 'ice cream';
  }

  render() {
    return <h1>I like {this.food}.</h1>;
  }
}
The simple answer is that this refers to an instance of IceCreamGuy
The less simple answer is that this refers to the object on which this‘s enclosing method, in this case .render()
Why don’t you need parentheses after this.food? Shouldn’t it be this.food()?
You don’t need those parentheses because .food is a getter method. You can tell this from the get in the above class declaration body.

Use an Event Listener in a Component
 the component class has two methods: .myFunc() and .render(). .myFunc() is being used as an event handler. .myFunc() will be called any time that a user hovers over the rendered <div></div>.
render() {
  return (
    <div onHover={myFunc}>
    </div>
  );
}

**Creating a React App

1. Set up the boilerplate application
Facebook has created a node module create-react-app to generate a boilerplate version of a React application.

Besides providing something that works out-of-the-box, this has the added benefit of providing a consistent structure for React apps that you will recognize as you move between React projects. It also provides an out-of-the-box build script and development server.
